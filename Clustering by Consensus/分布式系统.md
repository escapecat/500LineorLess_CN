
# 分布式系统
Dustin是一个开源的软件开发者，同时也是Mozilla的一名发布工程师。他参与的项目包括在Puppet中配置主机系统，一个基于Flask的Web框架，为防火墙配置做单元测试，还有一个在Twisted Python下开发的持续集成系统框架。你可以通过[GitHub](https://github.com/djmitche)或者<dustin@mozillar.com>联系他。
## 介绍
在这一章，我们将会一起探索如何实现一个网络协议用于可靠的分布式计算。正确实现一个网络协议并不简单，因此我们会采用一些技巧来尽可能的减少、查找和修复漏洞。要建立一个可靠地软件，同样需要一些特别的开发和调试技巧。
## 情景思考
这一章的重点在于网络协议的实现，但是首先让我们以简单的银行账户管理服务为例做一个思考。在这个服务中，每一个账户都有一个当前余额，同时每个账户都有自己的账号。用户可以通过“存款”、“转账”、“查询当前余额”等操作来连接账户。“转账”操作同时涉及了两个账户——转出账户和转入账户——并且如果账户余额不足，转账操作将会被驳回。  
  
如果这个服务仅仅在一个服务器上部署，很容易就能够实现：使用一个操作锁来确保“转账”操作不会同时进行，同时对转出账户的进行校验。然而，银行不可能仅仅依赖于一个服务器来储存账户余额这样的关键信息，通常，这些服务都是被分布在多个服务器上的，每一个服务器各自运行着相同代码的实例。用户可以通过任何一个服务器来操作账户。  
  
在一个简单的分布式处理系统的实现中，每个服务器都会保存一份账户余额的副本。它会处理任何收到的操作，并且将账户余额的更新发送给其他的服务器。但是这种方法有一个严重的问题：如果两个服务器同时对一个账户进行操作，哪一个新的账户余额是正确的？即使服务器不共享余额而是共享操作，对一个账户同时进行转账操作也可能造成透支。  
  
从根本上来说，这些错误的发生都是由于服务器使用它们本地状态来响应操作，而不是首先确保本地状态与其他服务器相匹配。比如，想象服务器A接到了从账号101向账号202转账的操作指令，而此时服务器B已经处理了另一个把账号101的钱都转到账号202的请求，却没有通知服务器A。这样，服务器A的本地状态与服务器B不一样，即使会造成账户101透支，服务器A依然允许从账号101进行转账操作。  
## 分布式状态机
为了防止上述情况发生我们采用了一种叫做“分布式状态机”的工具。它的思路是对每个同样的输入，每个服务器都运行同样的对应的状态机。由于状态机的特性，对于同样的输入每个服务器的输出都是一样的。对于像“转账”、“查询当前余额”等操作，账号和余额也都是状态机的输入。  
  
这个应用的状态机比较简单：
```python
 def execute_operation(state, operation):
     if operation.name == 'deposit':
         if not verify_signature(operation.deposit_signature):
         return state, False
         state.accounts[operation.destination_account] += operation.amount
         return state, True
     elif operation.name == 'transfer':
         if state.accounts[operation.source_account] < operation.amount:
             return state, False
             state.accounts[operation.source_account] -= operation.amount
         state.accounts[operation.destination_account] += operation.amount
         return state, True
     elif operation.name == 'get-balance':
     return state, state.accounts[operation.account]
 ```
值得注意的是，运行“查询当前余额”操作时虽然并不会改变当前状态，但是我们依然把它当做一个状态变化操作来实现。这确保了返回的余额是分布式系统中的最新信息，并且不是基于一个服务器上的本地状态来进行返回的。  
  
这可能跟你在计算机课程中学习到的典型的状态机不太一样。传统的状态机是一系列有限个状态的集合，每个状态都与一个标记的转移行为相对应，而在本文中，状态机的状态是账户余额的集合，因此存在无穷多个可能的状态。但是，状态机的基本规则同样适用于本文的状态机：对于同样的初始状态，同样的输入总是有同样的输出。  
  
因此，分布式状态机确保了对于同样的操作，每个主机都会有同样的相应。但是，为了确保每个服务器都允许状态机的输入，前文中提到的问题依然存在。这是一个一致性问题，为了解决它我们采用了一种派生的Paxos算法。  

## 用Paxos算法解决一致性问题  
Lamport在他的一篇精妙的名为“兼职议会”的论文中提出的，这篇论文首先提交于1990年，1998年才最终出版。Lamport的论文读起来很有意思，并且提供了更多的细节。在这章末尾的引用中介绍了本文中我们采用的算法的一些扩展。  

Paxos算法最简单的形式是为一组服务器提供了一种方法，始终用于通过一个决议 。Multi-Paxos算法基于此，可以一次通过一系列有限数量的决议。为了实现一个分布式状态机，我们使用Multi-Paxos算法去通过每一个状态机的输入，然后顺序执行。  

### Simple Paxos算法  
我们首先从“Simple Paxos”讲起，它也被称为神会协议，可以为一个永远不会改变的决议提供一种通过的方法。Paxos这个名字源于“兼职议会”中的神话岛屿，立法委员通过一个Lamport称之为“神会协议”的流程对法令进行投票。  

就如我们将看到的，这个算法是更复杂算法的基础。在这个例子中，我们将要通过的决议是我们虚拟银行中的第一笔交易。虽然银行每天会处理很多交易，但是第一笔交易只会发生一次，并且永远不会改变，因此我们可以采用Simple Paxos算法来进行处理。  

该协议通过一系列的投票来运行，每个投票由一个集群中的单个成员提起，称为proposer。每一个投票都有一个基于整数和提议者身份的独特的编码。proposer的目标就是让大多数集群成员（作为acceptors）接受这个投票值，但是前提是另一个的投票值尚未被接受。  

![图片](http://www.aosabook.org/en/500L/cluster-images/ballot.png)  
  
投票开始于proposer向acceptors发送一个带有编码N的Prepare消息，然后等待多数者回应。  

Prepare消息用于请求小于N的最大编号的批准决议（如果存在的话）。acceptors返回一个Promise消息，其中包含任何他们已经收到的决议，并承诺未来不接受任何编号小于N的投票。如果接受者已经向一个更大的编号做了承诺，Promise消息中会包含这个编号，表示这次请求被抢先。在这种情况下，此次投票已经结束，但提议者可以在另一次投票（采用更大的编号）再次尝试。  

当proposer收到了多数acceptors返回的消息后，它会发送一个包含编号和决议的Accept消息给所有的acceptors。如果proposer没有收到任何acceptors发来的已存在的决议，它会发送它的一个期望决议。否则，它会发送收到的Promice消息中编号最大的决议。  

只要它没有违反承诺，每个acceptors都会将Accept消息中包含的决议进行记录并且返回一个Accepted消息。当proposer从大多数的acceptors处收到了回应的编码时，本次投票就结束了，决议也通过了。  

让我们回到我们的例子，最初没有其他的决议被接收，因此acceptors都返回一个不带决议的Promise消息，提议者发送一个包含决议的Accept消息，如下：  
```
      operation(name='deposit', amount=100.00, destination_account='Mike DiBernardo')
```
如果另一个proposer接着发起了一个有更小编码和不同操作的（比如，转账给'Dustin J. Mitchell'）投票，acceptors将不会接受这个提议。如果这个编码更大，从acceptors返回的Promise消息将会包含Michael存款$100.00这个操作，接着proposer将在Accept消息中发送该决议，而不是发送“向Dustin转账”这个决议。接着新的投票请求会被接受，但是内容是第一次投票的决议。  

事实上，即使投票重复，消息延误或者少数acceptors无法连接，协议也永远不会允许两个不同的决议被通过。  

当多个proposer同时发起投票时，很可能两方的投票都不会被通过。两个proposer再次发起提议，当然更有希望的那个会成功，但是如果时间凑巧，投票死锁可以无限期地延续下去。  

考虑以下事件序列：  
- proposerA执行编码1的投票Prepare/Promise阶段  
- 在proposerA的决议被通过前，proposerB执行编码2的投票Prepare/Promise阶段  
- 当proposerA最终发送了带有编码1的Accept消息时，acceptors拒绝了，因为他们已经对编码2的投票做出承诺  
- 然后proposerA在编码2发送它的Accept消息之前，立即发送一个带有更大编码的Prepare消息（比如编码3）  
- proposerB的后续Accept消息被拒绝，整个过程重复  

由于时机不顺利——在发送消息和接受回应时间很长的长距离连接之间这种情况更为常见——这种死锁可能会持续多轮。  
